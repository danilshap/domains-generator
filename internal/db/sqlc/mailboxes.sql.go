// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: mailboxes.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createMailbox = `-- name: CreateMailbox :one
INSERT INTO mailboxes (
    address, 
    password, 
    domain_id, 
    user_id,
    created_at, 
    status
) VALUES (
    $1, $2, $3, 
    $4,
    NOW(), 
    $5
) RETURNING id, address, password, domain_id, created_at, status, is_deleted, settings, last_login, last_password_change, password_expires_at, user_id
`

type CreateMailboxParams struct {
	Address  string `json:"address"`
	Password string `json:"password"`
	DomainID int32  `json:"domain_id"`
	UserID   int32  `json:"user_id"`
	Status   int32  `json:"status"`
}

func (q *Queries) CreateMailbox(ctx context.Context, arg CreateMailboxParams) (Mailbox, error) {
	row := q.db.QueryRowContext(ctx, createMailbox,
		arg.Address,
		arg.Password,
		arg.DomainID,
		arg.UserID,
		arg.Status,
	)
	var i Mailbox
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Password,
		&i.DomainID,
		&i.CreatedAt,
		&i.Status,
		&i.IsDeleted,
		&i.Settings,
		&i.LastLogin,
		&i.LastPasswordChange,
		&i.PasswordExpiresAt,
		&i.UserID,
	)
	return i, err
}

const deleteMailbox = `-- name: DeleteMailbox :exec
UPDATE mailboxes 
SET is_deleted = true 
WHERE id = $1
`

func (q *Queries) DeleteMailbox(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteMailbox, id)
	return err
}

const getAllMailboxes = `-- name: GetAllMailboxes :many
SELECT m.id, m.address, m.password, m.domain_id, m.created_at, m.status, m.is_deleted, m.settings, m.last_login, m.last_password_change, m.password_expires_at, m.user_id, d.name as domain_name 
FROM mailboxes m
LEFT JOIN domains d ON m.domain_id = d.id
WHERE m.is_deleted = false
ORDER BY m.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllMailboxesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllMailboxesRow struct {
	ID                 int32                 `json:"id"`
	Address            string                `json:"address"`
	Password           string                `json:"password"`
	DomainID           int32                 `json:"domain_id"`
	CreatedAt          sql.NullTime          `json:"created_at"`
	Status             int32                 `json:"status"`
	IsDeleted          sql.NullBool          `json:"is_deleted"`
	Settings           pqtype.NullRawMessage `json:"settings"`
	LastLogin          sql.NullTime          `json:"last_login"`
	LastPasswordChange sql.NullTime          `json:"last_password_change"`
	PasswordExpiresAt  sql.NullTime          `json:"password_expires_at"`
	UserID             int32                 `json:"user_id"`
	DomainName         sql.NullString        `json:"domain_name"`
}

func (q *Queries) GetAllMailboxes(ctx context.Context, arg GetAllMailboxesParams) ([]GetAllMailboxesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMailboxes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMailboxesRow{}
	for rows.Next() {
		var i GetAllMailboxesRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Password,
			&i.DomainID,
			&i.CreatedAt,
			&i.Status,
			&i.IsDeleted,
			&i.Settings,
			&i.LastLogin,
			&i.LastPasswordChange,
			&i.PasswordExpiresAt,
			&i.UserID,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailboxByID = `-- name: GetMailboxByID :one
SELECT id, address, password, domain_id, created_at, status, is_deleted, settings, last_login, last_password_change, password_expires_at, user_id FROM mailboxes
WHERE id = $1 AND is_deleted = false
LIMIT 1
`

func (q *Queries) GetMailboxByID(ctx context.Context, id int32) (Mailbox, error) {
	row := q.db.QueryRowContext(ctx, getMailboxByID, id)
	var i Mailbox
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Password,
		&i.DomainID,
		&i.CreatedAt,
		&i.Status,
		&i.IsDeleted,
		&i.Settings,
		&i.LastLogin,
		&i.LastPasswordChange,
		&i.PasswordExpiresAt,
		&i.UserID,
	)
	return i, err
}

const getMailboxCountByDomainID = `-- name: GetMailboxCountByDomainID :one
SELECT COUNT(*) FROM mailboxes 
WHERE domain_id = $1 AND is_deleted = false
`

func (q *Queries) GetMailboxCountByDomainID(ctx context.Context, domainID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMailboxCountByDomainID, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailboxesByDomain = `-- name: GetMailboxesByDomain :many
SELECT id, address, password, domain_id, status, created_at
FROM mailboxes
WHERE address = $1 AND is_deleted = false
`

type GetMailboxesByDomainRow struct {
	ID        int32        `json:"id"`
	Address   string       `json:"address"`
	Password  string       `json:"password"`
	DomainID  int32        `json:"domain_id"`
	Status    int32        `json:"status"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetMailboxesByDomain(ctx context.Context, address string) ([]GetMailboxesByDomainRow, error) {
	rows, err := q.db.QueryContext(ctx, getMailboxesByDomain, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMailboxesByDomainRow{}
	for rows.Next() {
		var i GetMailboxesByDomainRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Password,
			&i.DomainID,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailboxesByDomainID = `-- name: GetMailboxesByDomainID :many
SELECT 
    m.id, m.address, m.password, m.domain_id, m.created_at, m.status, m.is_deleted, m.settings, m.last_login, m.last_password_change, m.password_expires_at, m.user_id,
    d.name as domain_name,
    d.status as domain_status
FROM mailboxes m
JOIN domains d ON d.id = m.domain_id
WHERE m.domain_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetMailboxesByDomainIDParams struct {
	DomainID int32 `json:"domain_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetMailboxesByDomainIDRow struct {
	ID                 int32                 `json:"id"`
	Address            string                `json:"address"`
	Password           string                `json:"password"`
	DomainID           int32                 `json:"domain_id"`
	CreatedAt          sql.NullTime          `json:"created_at"`
	Status             int32                 `json:"status"`
	IsDeleted          sql.NullBool          `json:"is_deleted"`
	Settings           pqtype.NullRawMessage `json:"settings"`
	LastLogin          sql.NullTime          `json:"last_login"`
	LastPasswordChange sql.NullTime          `json:"last_password_change"`
	PasswordExpiresAt  sql.NullTime          `json:"password_expires_at"`
	UserID             int32                 `json:"user_id"`
	DomainName         string                `json:"domain_name"`
	DomainStatus       int32                 `json:"domain_status"`
}

func (q *Queries) GetMailboxesByDomainID(ctx context.Context, arg GetMailboxesByDomainIDParams) ([]GetMailboxesByDomainIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getMailboxesByDomainID, arg.DomainID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMailboxesByDomainIDRow{}
	for rows.Next() {
		var i GetMailboxesByDomainIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Password,
			&i.DomainID,
			&i.CreatedAt,
			&i.Status,
			&i.IsDeleted,
			&i.Settings,
			&i.LastLogin,
			&i.LastPasswordChange,
			&i.PasswordExpiresAt,
			&i.UserID,
			&i.DomainName,
			&i.DomainStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailboxesByDomainName = `-- name: GetMailboxesByDomainName :many
SELECT id, address, status, created_at
FROM mailboxes
WHERE domain_id = $1 AND is_deleted = false
ORDER BY created_at DESC
`

type GetMailboxesByDomainNameRow struct {
	ID        int32        `json:"id"`
	Address   string       `json:"address"`
	Status    int32        `json:"status"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetMailboxesByDomainName(ctx context.Context, domainID int32) ([]GetMailboxesByDomainNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getMailboxesByDomainName, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMailboxesByDomainNameRow{}
	for rows.Next() {
		var i GetMailboxesByDomainNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailboxesByUserID = `-- name: GetMailboxesByUserID :many
SELECT id, address, password, domain_id, created_at, status, is_deleted, settings, last_login, last_password_change, password_expires_at, user_id FROM mailboxes
WHERE user_id = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetMailboxesByUserIDParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetMailboxesByUserID(ctx context.Context, arg GetMailboxesByUserIDParams) ([]Mailbox, error) {
	rows, err := q.db.QueryContext(ctx, getMailboxesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Mailbox{}
	for rows.Next() {
		var i Mailbox
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Password,
			&i.DomainID,
			&i.CreatedAt,
			&i.Status,
			&i.IsDeleted,
			&i.Settings,
			&i.LastLogin,
			&i.LastPasswordChange,
			&i.PasswordExpiresAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailboxesCount = `-- name: GetMailboxesCount :one
SELECT COUNT(*) 
FROM mailboxes 
WHERE user_id = $1 
  AND CASE WHEN array_length($2::int[], 1) > 0 THEN domain_id = ANY($2) ELSE true END
`

type GetMailboxesCountParams struct {
	UserID       int32   `json:"user_id"`
	DomainFilter []int32 `json:"domain_filter"`
}

func (q *Queries) GetMailboxesCount(ctx context.Context, arg GetMailboxesCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMailboxesCount, arg.UserID, pq.Array(arg.DomainFilter))
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailboxesCountByDomainID = `-- name: GetMailboxesCountByDomainID :one
SELECT COUNT(*) FROM mailboxes 
WHERE domain_id = $1
`

func (q *Queries) GetMailboxesCountByDomainID(ctx context.Context, domainID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMailboxesCountByDomainID, domainID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailboxesStats = `-- name: GetMailboxesStats :one
SELECT 
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status = 1) as active_count,
    COUNT(*) FILTER (WHERE status = 2) as inactive_count,
    COUNT(DISTINCT domain_id) as domains_count
FROM mailboxes
WHERE is_deleted = false AND user_id = $1
`

type GetMailboxesStatsRow struct {
	TotalCount    int64 `json:"total_count"`
	ActiveCount   int64 `json:"active_count"`
	InactiveCount int64 `json:"inactive_count"`
	DomainsCount  int64 `json:"domains_count"`
}

func (q *Queries) GetMailboxesStats(ctx context.Context, userID int32) (GetMailboxesStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getMailboxesStats, userID)
	var i GetMailboxesStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.ActiveCount,
		&i.InactiveCount,
		&i.DomainsCount,
	)
	return i, err
}

const getMailboxesWithFilters = `-- name: GetMailboxesWithFilters :many
SELECT m.id, m.address, m.password, m.domain_id, m.created_at, m.status, m.is_deleted, m.settings, m.last_login, m.last_password_change, m.password_expires_at, m.user_id, d.name as domain_name 
FROM mailboxes m
LEFT JOIN domains d ON m.domain_id = d.id
WHERE m.is_deleted = false
  AND CASE WHEN array_length($1::int[], 1) > 0 THEN m.status = ANY($1) ELSE true END
  AND CASE WHEN array_length($2::int[], 1) > 0 THEN m.domain_id = ANY($2) ELSE true END
  AND ($3::text = '' OR m.address ILIKE '%' || $3 || '%')
  AND ($4::int IS NULL OR m.user_id = $4)
ORDER BY m.created_at DESC
LIMIT $6 OFFSET $5
`

type GetMailboxesWithFiltersParams struct {
	StatusFilter []int32 `json:"status_filter"`
	DomainFilter []int32 `json:"domain_filter"`
	SearchQuery  string  `json:"search_query"`
	UserID       int32   `json:"user_id"`
	PageOffset   int32   `json:"page_offset"`
	PageLimit    int32   `json:"page_limit"`
}

type GetMailboxesWithFiltersRow struct {
	ID                 int32                 `json:"id"`
	Address            string                `json:"address"`
	Password           string                `json:"password"`
	DomainID           int32                 `json:"domain_id"`
	CreatedAt          sql.NullTime          `json:"created_at"`
	Status             int32                 `json:"status"`
	IsDeleted          sql.NullBool          `json:"is_deleted"`
	Settings           pqtype.NullRawMessage `json:"settings"`
	LastLogin          sql.NullTime          `json:"last_login"`
	LastPasswordChange sql.NullTime          `json:"last_password_change"`
	PasswordExpiresAt  sql.NullTime          `json:"password_expires_at"`
	UserID             int32                 `json:"user_id"`
	DomainName         sql.NullString        `json:"domain_name"`
}

func (q *Queries) GetMailboxesWithFilters(ctx context.Context, arg GetMailboxesWithFiltersParams) ([]GetMailboxesWithFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getMailboxesWithFilters,
		pq.Array(arg.StatusFilter),
		pq.Array(arg.DomainFilter),
		arg.SearchQuery,
		arg.UserID,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMailboxesWithFiltersRow{}
	for rows.Next() {
		var i GetMailboxesWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Password,
			&i.DomainID,
			&i.CreatedAt,
			&i.Status,
			&i.IsDeleted,
			&i.Settings,
			&i.LastLogin,
			&i.LastPasswordChange,
			&i.PasswordExpiresAt,
			&i.UserID,
			&i.DomainName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByMailboxID = `-- name: GetUserByMailboxID :one
SELECT u.id, u.username, u.email, u.hashed_password, u.full_name, u.role, u.is_active, u.created_at, u.updated_at FROM users u
JOIN mailboxes m ON m.user_id = u.id
WHERE m.id = $1 AND u.is_active = true
LIMIT 1
`

func (q *Queries) GetUserByMailboxID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByMailboxID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Role,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setMailboxStatus = `-- name: SetMailboxStatus :exec
UPDATE mailboxes
SET status = $1
WHERE id = $2
`

type SetMailboxStatusParams struct {
	Status int32 `json:"status"`
	ID     int32 `json:"id"`
}

func (q *Queries) SetMailboxStatus(ctx context.Context, arg SetMailboxStatusParams) error {
	_, err := q.db.ExecContext(ctx, setMailboxStatus, arg.Status, arg.ID)
	return err
}

const updateMailboxPassword = `-- name: UpdateMailboxPassword :exec
UPDATE mailboxes
SET password = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateMailboxPasswordParams struct {
	ID       int32  `json:"id"`
	Password string `json:"password"`
}

func (q *Queries) UpdateMailboxPassword(ctx context.Context, arg UpdateMailboxPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateMailboxPassword, arg.ID, arg.Password)
	return err
}

const updateMailboxesStatusByDomainID = `-- name: UpdateMailboxesStatusByDomainID :exec
UPDATE mailboxes 
SET status = $1
WHERE domain_id = $2 AND is_deleted = false
`

type UpdateMailboxesStatusByDomainIDParams struct {
	Status   int32 `json:"status"`
	DomainID int32 `json:"domain_id"`
}

func (q *Queries) UpdateMailboxesStatusByDomainID(ctx context.Context, arg UpdateMailboxesStatusByDomainIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMailboxesStatusByDomainID, arg.Status, arg.DomainID)
	return err
}

const updateMailboxesStatusByID = `-- name: UpdateMailboxesStatusByID :exec
UPDATE mailboxes 
SET status = $1
WHERE id = $2 AND is_deleted = false
`

type UpdateMailboxesStatusByIDParams struct {
	Status int32 `json:"status"`
	ID     int32 `json:"id"`
}

func (q *Queries) UpdateMailboxesStatusByID(ctx context.Context, arg UpdateMailboxesStatusByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMailboxesStatusByID, arg.Status, arg.ID)
	return err
}
